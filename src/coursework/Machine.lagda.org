* virtual machine time

#+begin_src agda2

{-# OPTIONS --safe --guardedness #-}
module coursework.Machine where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Function

open import Cubical.Data.Empty as âŠ¥
open import Cubical.Data.Digit
-- open import Data.Product using (map)
open import Cubical.Data.Nat
open import Cubical.Data.Bool using (T) renaming (Bool to ğ”¹; false to fâ€²; true to tâ€²)
open import Cubical.Data.Fin.Base using (Fin; zero; suc; pred; toâ„•)
open import Cubical.Data.Maybe
open import Cubical.Data.Vec.Base

open import Cubical.Relation.Nullary

open import Cubical.Instances.DecEq

open import coursework.Bits
open Serializable

#+end_src

* Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€ Ñ„Ğ»Ğ°Ğ³Ğ¾Ğ²
** Ğ•ÑĞ»Ğ¸ Ñ„Ğ»Ğ°Ğ³ ~stop~ Ğ¿Ğ¾Ğ´Ğ½ÑÑ‚, Ñ‚Ğ¾ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ¾Ñ€ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½, Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¹ Ğ¿Ñ€ĞµĞºÑ€Ğ°Ñ‰Ğ°ĞµÑ‚ÑÑ
** ~overflow~ Ğ²Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ğ¿Ñ€Ğ¸ Ñ†ĞµĞ»Ğ¾Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ½Ğ¾Ğ¼ Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ² Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸ÑÑ… ÑĞ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ¸ ÑƒĞ¼Ğ½Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
   Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ

#+begin_src agda2

record Flags : Typeâ‚€ where
  constructor mkFlags
  field
    stop     : Bit
    overflow : Bit
open Flags

-- instance
--   decEqFlags : DecEq Flags
--   DecEq._â‰Ÿ_ decEqFlags x y with stop x â‰Ÿ stop y
--   ... | no Â¬f = no Î» p â†’ Â¬f (cong stop p)
--   ... | yes f with overflow x â‰Ÿ overflow y
--   ... | no Â¬o = no Î» p â†’ Â¬o (cong overflow p)
--   ... | yes o = yes (congâ‚‚ mkFlags f o)

initFlags : Flags
initFlags = record
  { stop     = 0b
  ; overflow = 0b
  }

stopá¶  : Flags â†’ Flags
stopá¶  f = record f { stop = 1b }

overflowá¶  : Bit â†’ Flags â†’ Flags
overflowá¶  of f = record f { overflow = of }

#+end_src

* ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° ĞºĞ¾Ğ¼Ğ¿ÑŒÑÑ‚ĞµÑ€Ğ°
Ğ’Ğ¼ĞµÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¸Ğ²Ñ‹Ñ‡Ğ½Ğ¾Ğ¹ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ñ‹ Ñ„Ğ¾Ğ½ ĞĞµĞ¹Ğ¼Ğ°Ğ½Ğ° Ğ±ÑƒĞ´ĞµĞ¼ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ“Ğ°Ñ€Ğ²Ğ°Ñ€Ğ´ÑĞºÑƒÑ.
Ğ”Ğ»Ñ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¹ ĞµÑÑ‚ÑŒ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾Ğµ read-only Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ ~program~, instruction pointer ~ip~
ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ ĞºÑƒĞ´Ğ°-Ñ‚Ğ¾ Ğ²Ğ½ÑƒÑ‚Ñ€ÑŒ ÑÑ‚Ğ¾Ğ³Ğ¾ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğ°, Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ½Ğ° Ğ½ÑƒĞ»ĞµĞ²Ğ¾Ğ¹ Ğ±Ğ°Ğ¹Ñ‚.
Ğ”Ğ»Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ĞµÑÑ‚ÑŒ ÑÑ‚ĞµĞº.

ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ ĞµĞ´Ğ¸Ğ½Ğ¸Ñ†Ğ° Ğ°Ğ´Ñ€ĞµÑĞ°Ñ†Ğ¸Ğ¸ â€” 1 Ğ±Ğ°Ğ¹Ñ‚.
Ğ Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ¾Ñ€Ğ½Ğ¾Ğ³Ğ¾ ÑĞ»Ğ¾Ğ²Ğ° â€” 2 Ğ±Ğ°Ğ¹Ñ‚Ğ°.

#+begin_src agda2

record MS (programSize : â„•) (program : ByteArray programSize) : Typeâ‚€ where
  constructor mkMS
  field
    ip        : BytePtr programSize
    flags     : Flags
    stackSize : â„•
    stack     : ByteArray stackSize
open MS

initMachineState : (ps : â„•)
              (p : ByteArray ps) (ss : â„•) â†’
              MS ps p
initMachineState zero p ss = ?
initMachineState (suc ps) p ss = record
  { ip = zero
  ; flags = initFlags
  ; stackSize = ss
  ; stack = memset 0byte
  }

private
  variable
    ps psâ€² ss n : â„•
    p : ByteArray ps

-- it wraps around
incIP : BytePtr (suc ps) â†’ BytePtr (suc ps)
incIP {ps} ip with toâ„• ip â‰Ÿ ps
... | yes _ = zero
... | no  p with helper ip p
  where
  helper : {ps : â„•} â†’ (ip : BytePtr (suc ps)) â†’ (toâ„• ip â‰¢ ps) â†’ Î£ â„• Î» psâ€² â†’ ps â‰¡ suc psâ€²
  helper {zero        } zero       p = âŠ¥.rec (p refl)
  helper {suc zero    } zero       _ = zero , refl
  helper {suc zero    } (suc zero) p = âŠ¥.rec (p refl)
  helper {suc (suc ps)} _          _ = suc ps , refl
... | psâ€² , refl with ip
... | zero    = suc ? -- zero
... | suc ipâ€² = suc ? -- (incIP ipâ€²)

private variable
  â„“ : Level
  A : Type â„“

iterate : â„• â†’ (A â†’ A) â†’ (A â†’ A)
iterate 0       _ x = x
iterate (suc n) f x = iterate n f (f x)

advanceIP : BytePtr (suc ps) â†’ BytePtr (suc ps)
advanceIP = iterate 2 incIP

#+end_src

* Instruction set

#+begin_src agda2

data Instr : Typeâ‚€ where
  push         :     Byte â†’ Instr
  pop          :            Instr
  add          :            Instr
-- sub mul  :            Instr
  eq           :            Instr
--  neq le gt :            Instr
--   skip         :     Byte â†’ Instr
  skipIf       : ğ”¹ â†’ Byte â†’ Instr
  nop halt     :            Instr
  df           :            Instr

Program : (n : â„•) â†’ Typeâ‚€
Program n = Vec Instr n

-- instance
--   showInstr : Show Instr
--   showInstr = deriveShow InstrD

-- bitsAndBytes : Bits 16 â†” ByteArray 2
-- to bitsAndBytes = record
--   { _âŸ¨$âŸ©_ = Î» where
--       (bâ‚€ âˆ· bâ‚ âˆ· bâ‚‚ âˆ· bâ‚ƒ âˆ· bâ‚„ âˆ· bâ‚… âˆ· bâ‚† âˆ· bâ‚‡ âˆ· bs) â†’ (bâ‚€ âˆ· bâ‚ âˆ· bâ‚‚ âˆ· bâ‚ƒ âˆ· bâ‚„ âˆ· bâ‚… âˆ· bâ‚† âˆ· bâ‚‡ âˆ· []) âˆ· bs âˆ· []
--   ; cong = Î» { refl â†’ refl }
--   }
-- from bitsAndBytes = record
--   { _âŸ¨$âŸ©_ = Î» where
--       (x âˆ· y âˆ· []) â†’ x ++ y
--   ; cong = Î» { refl â†’ refl }
--   }
-- inverse-of bitsAndBytes = record
--   { left-inverse-of = Î» where
--       (bâ‚€ âˆ· bâ‚ âˆ· bâ‚‚ âˆ· bâ‚ƒ âˆ· bâ‚„ âˆ· bâ‚… âˆ· bâ‚† âˆ· bâ‚‡ âˆ· bs) â†’ refl
--   ; right-inverse-of = Î» where
--       ((bâ‚€ âˆ· bâ‚ âˆ· bâ‚‚ âˆ· bâ‚ƒ âˆ· bâ‚„ âˆ· bâ‚… âˆ· bâ‚† âˆ· bâ‚‡ âˆ· []) âˆ· bs âˆ· []) â†’ refl
--   }
  
serInstr : Serializable Instr 2
serInstr = record { encode = encodeâ€² ; decode = decodeâ€² ; decodeâˆ˜encode = inversesâ‚ ; encodeâˆ˜decode = inversesâ‚‚ }
  where
  encodeâ€² : Instr â†’ ByteArray 2
  encodeâ€² halt          = 0byte                                        âˆ· 0byte âˆ· []
  encodeâ€² nop           = (0b âˆ· 0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² (skip b)      = (0b âˆ· 0b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· b     âˆ· []
  encodeâ€² (skipIf fâ€² b) = (0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· b     âˆ· []
  encodeâ€² (skipIf tâ€² b) = (0b âˆ· 1b âˆ· 0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· b     âˆ· []
  encodeâ€² (push b)      = (0b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· b     âˆ· []
  encodeâ€² pop           = (0b âˆ· 1b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
  encodeâ€² add           = (1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² sub           = (1b âˆ· 0b âˆ· 0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
  encodeâ€² eq            = (1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
  encodeâ€² df            = (1b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² mul           = (1b âˆ· 0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² neq           = (1b âˆ· 1b âˆ· 0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² le            = (1b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² gt            = (1b âˆ· 1b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []

  decodeâ€² : ByteArray 2 â†’ Maybe Instr
  decodeâ€² (0byteâ‚š                                               âˆ· 0byteâ‚š âˆ· []) = just halt
  decodeâ€² ((0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just nop
--   decodeâ€² ((0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· b      âˆ· []) = just (skip b)
  decodeâ€² ((0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· b      âˆ· []) = just (skipIf fâ€² b)
  decodeâ€² ((0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· b      âˆ· []) = just (skipIf tâ€² b)
  decodeâ€² ((0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· b      âˆ· []) = just (push b)
  decodeâ€² ((0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just pop
  decodeâ€² ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just add
--   decodeâ€² ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just sub
--   decodeâ€² ((1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just mul
  decodeâ€² ((1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just eq
  decodeâ€² ((1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just df
--   decodeâ€² ((1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just neq
--   decodeâ€² ((1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just le
--   decodeâ€² ((1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just gt
  decodeâ€² _ = nothing
  
  inversesâ‚ : (i : Instr) â†’ decodeâ€² (encodeâ€² i) â‰¡ just i
  inversesâ‚ (push x) = refl
  inversesâ‚ pop = refl
  inversesâ‚ add = refl
--   inversesâ‚ sub = refl
--   inversesâ‚ mul = refl
  inversesâ‚ eq = refl
--   inversesâ‚ neq = refl
--   inversesâ‚ le = refl
--   inversesâ‚ gt = refl
--   inversesâ‚ (skip _) = refl
  inversesâ‚ (skipIf fâ€² _) = refl
  inversesâ‚ (skipIf tâ€² _) = refl
  inversesâ‚ nop = refl
  inversesâ‚ halt = refl
  inversesâ‚ df = refl

  inversesâ‚‚ : (ba : ByteArray 2) {i : Instr} â†’ decodeâ€² ba â‰¡ just i â†’ ba â‰¡ encodeâ€² i
  inversesâ‚‚ = ?
--   inversesâ‚‚ (0byteâ‚š                                               âˆ· 0byteâ‚š âˆ· []) refl = ?
--   inversesâ‚‚ ((0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = ?
-- --   inversesâ‚‚ ((0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· _      âˆ· []) refl = refl
--   inversesâ‚‚ ((0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· _      âˆ· []) refl = ?
--   inversesâ‚‚ ((0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· _      âˆ· []) refl = ?
--   inversesâ‚‚ ((0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· _      âˆ· []) refl = ?
--   inversesâ‚‚ ((0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = ?
--   inversesâ‚‚ ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = ?
-- --   inversesâ‚‚ ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
-- --   inversesâ‚‚ ((1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
--   inversesâ‚‚ ((1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = ?
--   inversesâ‚‚ ((1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = ?
-- --   inversesâ‚‚ ((1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
-- --   inversesâ‚‚ ((1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
-- --   inversesâ‚‚ ((1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl

instance
  serBool : Serializable ğ”¹ 1
  serBool = record
    { encode = Î» where
        fâ€² â†’ 0byte âˆ· []
        tâ€² â†’ (1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· []
    ; decode = Î» where
        (0byteâ‚š âˆ· []                                              ) â†’ just fâ€²
        ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· []) â†’ just tâ€²
        _                                                           â†’ nothing
    ; decodeâˆ˜encode = Î» where
        fâ€² â†’ refl
        tâ€² â†’ refl
    ; encodeâˆ˜decode = Î» where
        (0byteâ‚š âˆ· []) refl â†’ ?
        ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· []) refl â†’ ?
    }

#+end_src

* Ğ˜Ğ½Ñ‚ĞµÑ€Ğ¿Ñ€ĞµÑ‚Ğ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´
** fetch command at ip
** if it's invalid stop
** if it's valid then execute it and advance ip

#+begin_src agda2

-- private
--   instance
--     â‰¤-dec : {p : T (m â‰¤áµ‡ n)} â†’ m â‰¤ n
--     â‰¤-dec {p = p} = â‰¤áµ‡â‡’â‰¤ _ _ p

-- fetch : MS ps p â†’ Maybe (ByteArray 2)
-- fetch {ps = suc (suc ps)} {p = p} ms with toâ„• (ip ms) â‰¤? ps
-- ... | yes q = just $ slice_at_as_ p (ip ms) 2 â¦ƒ sâ‰¤s (sâ‰¤s q) â¦„
-- ... | no  _ = nothing
-- fetch {ps = _           } _ = nothing

fetch : MS ps p â†’ Maybe (ByteArray 2)
fetch = ?

stopáµ : MS ps p â†’ MS ps p
stopáµ ms = record ms { flags = stopá¶  $ ms .flags }

overflowáµ : Bit â†’ MS ps p â†’ MS ps p
overflowáµ of ms = record ms { flags = overflowá¶  of $ ms .flags }

advanceIPáµ : MS (suc ps) p â†’ MS (suc ps) p
advanceIPáµ ms = record ms { ip = advanceIP $ ms .ip }

updateStackáµ : (f : Î£ â„• ByteArray â†’ Î£ â„• ByteArray) â†’ MS ps p â†’ MS ps p
updateStackáµ f ms = let ssâ€² , stackâ€² = f (_ , ms .stack) in record ms { stackSize = ssâ€² ; stack = stackâ€²}

pusháµ : Byte â†’ MS ps p â†’ MS ps p
pusháµ x ms = record ms { stackSize = suc (ms .stackSize) ; stack = x âˆ· ms .stack}

popáµ : MS ps p â†’ MS ps p
popáµ ms with ms .stackSize in sEq
... | 0      = stopáµ ms
... | suc ss = record ms { stackSize = ss ; stack = tail (subst ByteArray ? (ms .stack)) }
-- ... | suc ss = record ms { stackSize = ss ; stack = tail (subst ByteArray sEq (ms .stack)) }

execute : MS (suc ps) p â†’ Instr â†’ MS (suc ps) p
execute ms (push b) = advanceIPáµ $ pusháµ b $ ms
execute ms pop with stackSize ms
... | suc ss = advanceIPáµ $ popáµ $ ms
... | 0      = stopáµ ms
execute ms add with stackSize ms in sEq
... | 0            = stopáµ ms
... | 1            = stopáµ ms
... | suc (suc ss) with slice (subst ByteArray ? (stack ms)) at zero as 2
-- ... | suc (suc ss) with slice (subst ByteArray sEq (stack ms)) at zero as 2
... | bâ‚ âˆ· bâ‚‚ âˆ· [] = let carry , res = bâ‚ +áµ‡ bâ‚‚ in advanceIPáµ $ overflowáµ carry $ pusháµ res $ popáµ $ popáµ ms
execute ms eq with stackSize ms in sEq
... | 0 = stopáµ ms
... | 1 = stopáµ ms
... | suc (suc ss) with slice (subst ByteArray ? (stack ms)) at zero as 2
-- ... | suc (suc ss) with slice (subst ByteArray sEq (stack ms)) at zero as 2
... | bâ‚ âˆ· bâ‚‚ âˆ· [] with âŒŠ bâ‚ â‰Ÿ bâ‚‚ âŒ‹
... | d = advanceIPáµ $ pusháµ (single (encode serBool d)) $ popáµ $ popáµ ms
execute ms (skipIf c n) with stackSize ms in sEq
... | 0      = stopáµ ms
... | suc ss with decode serBool (take 1 (subst ByteArray sEq (stack ms)))
... | nothing = stopáµ ms
... | just câ€² with âŒŠ c â‰Ÿ câ€² âŒ‹
... | tâ€² = record ms { ip = ? ; stackSize = ss; stack = tail (subst ByteArray sEq (stack ms))}
-- ... | tâ€² = record ms { ip = iterate (decodeByteAsâ„• n) incIP (ip ms) ; stackSize = ss; stack = tail (subst ByteArray sEq (stack ms))}
... | fâ€² = record ms { ip = advanceIP (ip ms) ; stackSize = ss; stack = tail (subst ByteArray sEq (stack ms))}
execute ms nop =  advanceIPáµ ms
execute ms halt = stopáµ ms
execute ms df   = execute ms (push $ overflow (flags ms) âˆ· replicate 0b)

-- fetch instruction, decode, execute
step : MS (suc ps) p â†’ MS (suc ps) p
step ms = ?

-- step : MS (suc ps) p â†’ MS (suc ps) p
-- step ms with stop (flags ms)
-- ... | 1bâ‚š = ms
-- ... | 0bâ‚š with fetch ms >>= decode serInstr
-- ... | nothing = stopáµ ms
-- ... | just i  = execute ms i

record _â‰ˆ_ (x y : MS (suc ps) p) : Typeâ‚€ where
  coinductive
  field
    sameFlags     : flags x â‰¡ flags y
    sameStackSize : stackSize x â‰¡ stackSize y
    sameStack     : subst ByteArray sameStackSize (stack x) â‰¡ stack y
    sameCont      : step x â‰ˆ step y

MachineExtensionality : Typeâ‚€
MachineExtensionality = âˆ€ {ps p} â†’ {x y : MS (suc ps) p} â†’ x â‰ˆ y â†’ x â‰¡ y

assemble : Program n â†’ ByteArray (n Â· 2)
assemble []       = []
assemble (i âˆ· is) = encode serInstr i ++ assemble is

runáµ_for_steps : MS (suc ps) p â†’ â„• â†’ MS (suc ps) p
runáµ ms for 0     steps = ms
runáµ ms for suc n steps = runáµ (step ms) for n steps

Haltsáµ : MS (suc ps) p â†’ Typeâ‚€
Haltsáµ ms = Î£ â„• Î» n â†’ stop (flags (runáµ ms for n steps)) â‰¡ 1b

module Test {machine-ext : MachineExtensionality} where

  trivial : MS _ _
  trivial = initMachineState _ (assemble $ push 1byte âˆ· push 1byte âˆ· add âˆ· halt âˆ· []) 0

  trivial-halts : Haltsáµ trivial
  trivial-halts = 4 , refl

  loopyBoy : Vec Instr _
  loopyBoy = push 0byte âˆ· push 0byte âˆ· add âˆ· skipIf fâ€² (0b âˆ· 1b âˆ· replicate 0b) âˆ· []

  k : MS 8 _
  k = initMachineState _ (assemble loopyBoy) 0

  k-loops : k â‰ˆ (runáµ k for 4 steps)
  _â‰ˆ_.sameFlags k-loops = refl
  _â‰ˆ_.sameStackSize k-loops = refl
  _â‰ˆ_.sameStack k-loops = refl
  _â‰ˆ_.sameFlags (_â‰ˆ_.sameCont k-loops) = refl
  _â‰ˆ_.sameStackSize (_â‰ˆ_.sameCont k-loops) = refl
  _â‰ˆ_.sameStack (_â‰ˆ_.sameCont k-loops) = refl
  _â‰ˆ_.sameFlags (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops)) = refl
  _â‰ˆ_.sameStackSize (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops)) = refl
  _â‰ˆ_.sameStack (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops)) = refl
  _â‰ˆ_.sameFlags (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops))) = refl
  _â‰ˆ_.sameStackSize (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops))) = refl
  _â‰ˆ_.sameStack (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops))) = refl
  _â‰ˆ_.sameCont (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops))) = k-loops

  some-programs-do-not-halt : Â¬ Haltsáµ k
  some-programs-do-not-halt (n , prf) = helper n prf
    where
    helper : (n : â„•) â†’ stop (flags (runáµ k for n steps)) â‰¡ 1b â†’ âŠ¥
    helper (suc (suc (suc (suc n)))) prf =
      helper n $ subst (Î» j â†’ stop (flags (runáµ j for n steps)) â‰¡ 1b) (sym $ machine-ext k-loops) prf

#+end_src
