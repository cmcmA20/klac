* virtual machine time

#+begin_src agda2

{-# OPTIONS --safe --guardedness #-}
module coursework.Machine where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Function

open import Cubical.Data.Empty as ‚ä•
open import Cubical.Data.Digit
-- open import Data.Product using (map)
open import Cubical.Data.Nat
open import Cubical.Data.Bool using (T) renaming (Bool to ùîπ; false to f‚Ä≤; true to t‚Ä≤)
open import Cubical.Data.Fin.Base using (Fin; zero; suc; pred; to‚Ñï)
open import Cubical.Data.Maybe
open import Cubical.Data.Vec.Base

open import Cubical.Relation.Nullary

open import Cubical.Instances.DecEq

open import coursework.Bits
open Serializable

#+end_src

* –†–µ–≥–∏—Å—Ç—Ä —Ñ–ª–∞–≥–æ–≤
** –ï—Å–ª–∏ —Ñ–ª–∞–≥ ~stop~ –ø–æ–¥–Ω—è—Ç, —Ç–æ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –ø—Ä–µ–∫—Ä–∞—â–∞–µ—Ç—Å—è
** ~overflow~ –≤–∑–≤–æ–¥–∏—Ç—Å—è –ø—Ä–∏ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–º –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–∏ –≤ –æ–ø–µ—Ä–∞—Ü–∏—è—Ö —Å–ª–æ–∂–µ–Ω–∏—è –∏ —É–º–Ω–æ–∂–µ–Ω–∏—è
   –ø–æ–∫–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è

#+begin_src agda2

record Flags : Type‚ÇÄ where
  constructor mkFlags
  field
    stop     : Bit
    overflow : Bit
open Flags

-- instance
--   decEqFlags : DecEq Flags
--   DecEq._‚âü_ decEqFlags x y with stop x ‚âü stop y
--   ... | no ¬¨f = no Œª p ‚Üí ¬¨f (cong stop p)
--   ... | yes f with overflow x ‚âü overflow y
--   ... | no ¬¨o = no Œª p ‚Üí ¬¨o (cong overflow p)
--   ... | yes o = yes (cong‚ÇÇ mkFlags f o)

initFlags : Flags
initFlags = record
  { stop     = 0b
  ; overflow = 0b
  }

stop·∂† : Flags ‚Üí Flags
stop·∂† f = record f { stop = 1b }

overflow·∂† : Bit ‚Üí Flags ‚Üí Flags
overflow·∂† of f = record f { overflow = of }

#+end_src

* –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞
–í–º–µ—Å—Ç–æ –ø—Ä–∏–≤—ã—á–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã —Ñ–æ–Ω –ù–µ–π–º–∞–Ω–∞ –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ì–∞—Ä–≤–∞—Ä–¥—Å–∫—É—é.
–î–ª—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –µ—Å—Ç—å –æ—Ç–¥–µ–ª—å–Ω–æ–µ read-only —Ö—Ä–∞–Ω–∏–ª–∏—â–µ ~program~, instruction pointer ~ip~
—É–∫–∞–∑—ã–≤–∞–µ—Ç –∫—É–¥–∞-—Ç–æ –≤–Ω—É—Ç—Ä—å —ç—Ç–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞, –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –Ω–∞ –Ω—É–ª–µ–≤–æ–π –±–∞–π—Ç.
–î–ª—è –¥–∞–Ω–Ω—ã—Ö –µ—Å—Ç—å —Å—Ç–µ–∫.

–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –µ–¥–∏–Ω–∏—Ü–∞ –∞–¥—Ä–µ—Å–∞—Ü–∏–∏ ‚Äî 1 –±–∞–π—Ç.
–†–∞–∑–º–µ—Ä –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–Ω–æ–≥–æ —Å–ª–æ–≤–∞ ‚Äî 2 –±–∞–π—Ç–∞.

#+begin_src agda2

record MS (programSize : ‚Ñï) (program : ByteArray programSize) : Type‚ÇÄ where
  constructor mkMS
  field
    ip        : BytePtr programSize
    flags     : Flags
    stackSize : ‚Ñï
    stack     : ByteArray stackSize
open MS

initMachineState : (ps : ‚Ñï)
              (p : ByteArray ps) (ss : ‚Ñï) ‚Üí
              MS ps p
initMachineState zero p ss = ?
initMachineState (suc ps) p ss = record
  { ip = zero
  ; flags = initFlags
  ; stackSize = ss
  ; stack = memset 0byte
  }

private
  variable
    ps ps‚Ä≤ ss n : ‚Ñï
    p : ByteArray ps

-- it wraps around
incIP : BytePtr (suc ps) ‚Üí BytePtr (suc ps)
incIP {ps} ip with to‚Ñï ip ‚âü ps
... | yes _ = zero
... | no  p with helper ip p
  where
  helper : {ps : ‚Ñï} ‚Üí (ip : BytePtr (suc ps)) ‚Üí (to‚Ñï ip ‚â¢ ps) ‚Üí Œ£ ‚Ñï Œª ps‚Ä≤ ‚Üí ps ‚â° suc ps‚Ä≤
  helper {zero        } zero       p = ‚ä•.rec (p refl)
  helper {suc zero    } zero       _ = zero , refl
  helper {suc zero    } (suc zero) p = ‚ä•.rec (p refl)
  helper {suc (suc ps)} _          _ = suc ps , refl
... | ps‚Ä≤ , refl with ip
... | zero    = suc ? -- zero
... | suc ip‚Ä≤ = suc ? -- (incIP ip‚Ä≤)

private variable
  ‚Ñì : Level
  A : Type ‚Ñì

iterate : ‚Ñï ‚Üí (A ‚Üí A) ‚Üí (A ‚Üí A)
iterate 0       _ x = x
iterate (suc n) f x = iterate n f (f x)

advanceIP : BytePtr (suc ps) ‚Üí BytePtr (suc ps)
advanceIP = iterate 2 incIP

#+end_src

* Instruction set

#+begin_src agda2

data Instr : Type‚ÇÄ where
  push         :     Byte ‚Üí Instr
  pop          :            Instr
  add          :            Instr
-- sub mul  :            Instr
  eq           :            Instr
--  neq le gt :            Instr
--   skip         :     Byte ‚Üí Instr
  skipIf       : ùîπ ‚Üí Byte ‚Üí Instr
  nop halt     :            Instr
  df           :            Instr

Program : (n : ‚Ñï) ‚Üí Type‚ÇÄ
Program n = Vec Instr n

-- instance
--   showInstr : Show Instr
--   showInstr = deriveShow InstrD

-- bitsAndBytes : Bits 16 ‚Üî ByteArray 2
-- to bitsAndBytes = record
--   { _‚ü®$‚ü©_ = Œª where
--       (b‚ÇÄ ‚à∑ b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ b‚ÇÉ ‚à∑ b‚ÇÑ ‚à∑ b‚ÇÖ ‚à∑ b‚ÇÜ ‚à∑ b‚Çá ‚à∑ bs) ‚Üí (b‚ÇÄ ‚à∑ b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ b‚ÇÉ ‚à∑ b‚ÇÑ ‚à∑ b‚ÇÖ ‚à∑ b‚ÇÜ ‚à∑ b‚Çá ‚à∑ []) ‚à∑ bs ‚à∑ []
--   ; cong = Œª { refl ‚Üí refl }
--   }
-- from bitsAndBytes = record
--   { _‚ü®$‚ü©_ = Œª where
--       (x ‚à∑ y ‚à∑ []) ‚Üí x ++ y
--   ; cong = Œª { refl ‚Üí refl }
--   }
-- inverse-of bitsAndBytes = record
--   { left-inverse-of = Œª where
--       (b‚ÇÄ ‚à∑ b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ b‚ÇÉ ‚à∑ b‚ÇÑ ‚à∑ b‚ÇÖ ‚à∑ b‚ÇÜ ‚à∑ b‚Çá ‚à∑ bs) ‚Üí refl
--   ; right-inverse-of = Œª where
--       ((b‚ÇÄ ‚à∑ b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ b‚ÇÉ ‚à∑ b‚ÇÑ ‚à∑ b‚ÇÖ ‚à∑ b‚ÇÜ ‚à∑ b‚Çá ‚à∑ []) ‚à∑ bs ‚à∑ []) ‚Üí refl
--   }
  
serInstr : Serializable Instr 2
serInstr = record { encode = encode‚Ä≤ ; decode = decode‚Ä≤ ; decode‚àòencode = inverses‚ÇÅ ; encode‚àòdecode = inverses‚ÇÇ }
  where
  encode‚Ä≤ : Instr ‚Üí ByteArray 2
  encode‚Ä≤ halt          = 0byte                                        ‚à∑ 0byte ‚à∑ []
  encode‚Ä≤ nop           = (0b ‚à∑ 0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ (skip b)      = (0b ‚à∑ 0b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ b     ‚à∑ []
  encode‚Ä≤ (skipIf f‚Ä≤ b) = (0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ b     ‚à∑ []
  encode‚Ä≤ (skipIf t‚Ä≤ b) = (0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ b     ‚à∑ []
  encode‚Ä≤ (push b)      = (0b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ b     ‚à∑ []
  encode‚Ä≤ pop           = (0b ‚à∑ 1b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
  encode‚Ä≤ add           = (1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ sub           = (1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
  encode‚Ä≤ eq            = (1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
  encode‚Ä≤ df            = (1b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ mul           = (1b ‚à∑ 0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ neq           = (1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ le            = (1b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ gt            = (1b ‚à∑ 1b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []

  decode‚Ä≤ : ByteArray 2 ‚Üí Maybe Instr
  decode‚Ä≤ (0byte‚Çö                                               ‚à∑ 0byte‚Çö ‚à∑ []) = just halt
  decode‚Ä≤ ((0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just nop
--   decode‚Ä≤ ((0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ b      ‚à∑ []) = just (skip b)
  decode‚Ä≤ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ b      ‚à∑ []) = just (skipIf f‚Ä≤ b)
  decode‚Ä≤ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ b      ‚à∑ []) = just (skipIf t‚Ä≤ b)
  decode‚Ä≤ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ b      ‚à∑ []) = just (push b)
  decode‚Ä≤ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just pop
  decode‚Ä≤ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just add
--   decode‚Ä≤ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just sub
--   decode‚Ä≤ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just mul
  decode‚Ä≤ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just eq
  decode‚Ä≤ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just df
--   decode‚Ä≤ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just neq
--   decode‚Ä≤ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just le
--   decode‚Ä≤ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just gt
  decode‚Ä≤ _ = nothing
  
  inverses‚ÇÅ : (i : Instr) ‚Üí decode‚Ä≤ (encode‚Ä≤ i) ‚â° just i
  inverses‚ÇÅ (push x) = refl
  inverses‚ÇÅ pop = refl
  inverses‚ÇÅ add = refl
--   inverses‚ÇÅ sub = refl
--   inverses‚ÇÅ mul = refl
  inverses‚ÇÅ eq = refl
--   inverses‚ÇÅ neq = refl
--   inverses‚ÇÅ le = refl
--   inverses‚ÇÅ gt = refl
--   inverses‚ÇÅ (skip _) = refl
  inverses‚ÇÅ (skipIf f‚Ä≤ _) = refl
  inverses‚ÇÅ (skipIf t‚Ä≤ _) = refl
  inverses‚ÇÅ nop = refl
  inverses‚ÇÅ halt = refl
  inverses‚ÇÅ df = refl

  inverses‚ÇÇ : (ba : ByteArray 2) {i : Instr} ‚Üí decode‚Ä≤ ba ‚â° just i ‚Üí ba ‚â° encode‚Ä≤ i
  inverses‚ÇÇ = ?
--   inverses‚ÇÇ (0byte‚Çö                                               ‚à∑ 0byte‚Çö ‚à∑ []) refl = ?
--   inverses‚ÇÇ ((0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = ?
-- --   inverses‚ÇÇ ((0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ _      ‚à∑ []) refl = refl
--   inverses‚ÇÇ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ _      ‚à∑ []) refl = ?
--   inverses‚ÇÇ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ _      ‚à∑ []) refl = ?
--   inverses‚ÇÇ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ _      ‚à∑ []) refl = ?
--   inverses‚ÇÇ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = ?
--   inverses‚ÇÇ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = ?
-- --   inverses‚ÇÇ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
-- --   inverses‚ÇÇ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
--   inverses‚ÇÇ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = ?
--   inverses‚ÇÇ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = ?
-- --   inverses‚ÇÇ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
-- --   inverses‚ÇÇ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
-- --   inverses‚ÇÇ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl

instance
  serBool : Serializable ùîπ 1
  serBool = record
    { encode = Œª where
        f‚Ä≤ ‚Üí 0byte ‚à∑ []
        t‚Ä≤ ‚Üí (1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ []
    ; decode = Œª where
        (0byte‚Çö ‚à∑ []                                              ) ‚Üí just f‚Ä≤
        ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ []) ‚Üí just t‚Ä≤
        _                                                           ‚Üí nothing
    ; decode‚àòencode = Œª where
        f‚Ä≤ ‚Üí refl
        t‚Ä≤ ‚Üí refl
    ; encode‚àòdecode = Œª where
        (0byte‚Çö ‚à∑ []) refl ‚Üí ?
        ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ []) refl ‚Üí ?
    }

#+end_src

* –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥
** fetch command at ip
** if it's invalid stop
** if it's valid then execute it and advance ip

#+begin_src agda2

-- private
--   instance
--     ‚â§-dec : {p : T (m ‚â§·µá n)} ‚Üí m ‚â§ n
--     ‚â§-dec {p = p} = ‚â§·µá‚áí‚â§ _ _ p

-- fetch : MS ps p ‚Üí Maybe (ByteArray 2)
-- fetch {ps = suc (suc ps)} {p = p} ms with to‚Ñï (ip ms) ‚â§? ps
-- ... | yes q = just $ slice_at_as_ p (ip ms) 2 ‚¶É s‚â§s (s‚â§s q) ‚¶Ñ
-- ... | no  _ = nothing
-- fetch {ps = _           } _ = nothing

fetch : MS ps p ‚Üí Maybe (ByteArray 2)
fetch = ?

stop·µê : MS ps p ‚Üí MS ps p
stop·µê ms = record ms { flags = stop·∂† $ ms .flags }

overflow·µê : Bit ‚Üí MS ps p ‚Üí MS ps p
overflow·µê of ms = record ms { flags = overflow·∂† of $ ms .flags }

advanceIP·µê : MS (suc ps) p ‚Üí MS (suc ps) p
advanceIP·µê ms = record ms { ip = advanceIP $ ms .ip }

updateStack·µê : (f : Œ£ ‚Ñï ByteArray ‚Üí Œ£ ‚Ñï ByteArray) ‚Üí MS ps p ‚Üí MS ps p
updateStack·µê f ms = let ss‚Ä≤ , stack‚Ä≤ = f (_ , ms .stack) in record ms { stackSize = ss‚Ä≤ ; stack = stack‚Ä≤}

push·µê : Byte ‚Üí MS ps p ‚Üí MS ps p
push·µê x ms = record ms { stackSize = suc (ms .stackSize) ; stack = x ‚à∑ ms .stack}

pop·µê : MS ps p ‚Üí MS ps p
pop·µê ms with ms .stackSize in sEq
... | 0      = stop·µê ms
... | suc ss = record ms { stackSize = ss ; stack = tail (subst ByteArray ? (ms .stack)) }
-- ... | suc ss = record ms { stackSize = ss ; stack = tail (subst ByteArray sEq (ms .stack)) }

execute : MS (suc ps) p ‚Üí Instr ‚Üí MS (suc ps) p
execute ms (push b) = advanceIP·µê $ push·µê b $ ms
execute ms pop with stackSize ms
... | suc ss = advanceIP·µê $ pop·µê $ ms
... | 0      = stop·µê ms
execute ms add with stackSize ms in sEq
... | 0            = stop·µê ms
... | 1            = stop·µê ms
... | suc (suc ss) with slice (subst ByteArray ? (stack ms)) at zero as 2
-- ... | suc (suc ss) with slice (subst ByteArray sEq (stack ms)) at zero as 2
... | b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ [] = let carry , res = b‚ÇÅ +·µá b‚ÇÇ in advanceIP·µê $ overflow·µê carry $ push·µê res $ pop·µê $ pop·µê ms
execute ms eq with stackSize ms in sEq
... | 0 = stop·µê ms
... | 1 = stop·µê ms
... | suc (suc ss) with slice (subst ByteArray ? (stack ms)) at zero as 2
-- ... | suc (suc ss) with slice (subst ByteArray sEq (stack ms)) at zero as 2
... | b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ [] with ‚åä b‚ÇÅ ‚âü b‚ÇÇ ‚åã
... | d = advanceIP·µê $ push·µê (single (encode serBool d)) $ pop·µê $ pop·µê ms
execute ms (skipIf c n) with stackSize ms in sEq
... | 0      = stop·µê ms
... | suc ss with decode serBool (take 1 (subst ByteArray sEq (stack ms)))
... | nothing = stop·µê ms
... | just c‚Ä≤ with ‚åä c ‚âü c‚Ä≤ ‚åã
... | t‚Ä≤ = record ms { ip = ? ; stackSize = ss; stack = tail (subst ByteArray sEq (stack ms))}
-- ... | t‚Ä≤ = record ms { ip = iterate (decodeByteAs‚Ñï n) incIP (ip ms) ; stackSize = ss; stack = tail (subst ByteArray sEq (stack ms))}
... | f‚Ä≤ = record ms { ip = advanceIP (ip ms) ; stackSize = ss; stack = tail (subst ByteArray sEq (stack ms))}
execute ms nop =  advanceIP·µê ms
execute ms halt = stop·µê ms
execute ms df   = execute ms (push $ overflow (flags ms) ‚à∑ replicate 0b)

-- fetch instruction, decode, execute
step : MS (suc ps) p ‚Üí MS (suc ps) p
step ms = ?

-- step : MS (suc ps) p ‚Üí MS (suc ps) p
-- step ms with stop (flags ms)
-- ... | 1b‚Çö = ms
-- ... | 0b‚Çö with fetch ms >>= decode serInstr
-- ... | nothing = stop·µê ms
-- ... | just i  = execute ms i

record _‚âà_ (x y : MS (suc ps) p) : Type‚ÇÄ where
  coinductive
  field
    sameFlags     : flags x ‚â° flags y
    sameStackSize : stackSize x ‚â° stackSize y
    sameStack     : subst ByteArray sameStackSize (stack x) ‚â° stack y
    sameCont      : step x ‚âà step y

MachineExtensionality : Type‚ÇÄ
MachineExtensionality = ‚àÄ {ps p} ‚Üí {x y : MS (suc ps) p} ‚Üí x ‚âà y ‚Üí x ‚â° y

assemble : Program n ‚Üí ByteArray (n ¬∑ 2)
assemble []       = []
assemble (i ‚à∑ is) = encode serInstr i ++ assemble is

run·µê_for_steps : MS (suc ps) p ‚Üí ‚Ñï ‚Üí MS (suc ps) p
run·µê ms for 0     steps = ms
run·µê ms for suc n steps = run·µê (step ms) for n steps

Halts·µê : MS (suc ps) p ‚Üí Type‚ÇÄ
Halts·µê ms = Œ£ ‚Ñï Œª n ‚Üí stop (flags (run·µê ms for n steps)) ‚â° 1b

module Test {machine-ext : MachineExtensionality} where

  trivial : MS _ _
  trivial = initMachineState _ (assemble $ push 1byte ‚à∑ push 1byte ‚à∑ add ‚à∑ halt ‚à∑ []) 0

  trivial-halts : Halts·µê trivial
  trivial-halts = 4 , refl

  loopyBoy : Vec Instr _
  loopyBoy = push 0byte ‚à∑ push 0byte ‚à∑ add ‚à∑ skipIf f‚Ä≤ (0b ‚à∑ 1b ‚à∑ replicate 0b) ‚à∑ []

  k : MS 8 _
  k = initMachineState _ (assemble loopyBoy) 0

  k-loops : k ‚âà (run·µê k for 4 steps)
  _‚âà_.sameFlags k-loops = refl
  _‚âà_.sameStackSize k-loops = refl
  _‚âà_.sameStack k-loops = refl
  _‚âà_.sameFlags (_‚âà_.sameCont k-loops) = refl
  _‚âà_.sameStackSize (_‚âà_.sameCont k-loops) = refl
  _‚âà_.sameStack (_‚âà_.sameCont k-loops) = refl
  _‚âà_.sameFlags (_‚âà_.sameCont (_‚âà_.sameCont k-loops)) = refl
  _‚âà_.sameStackSize (_‚âà_.sameCont (_‚âà_.sameCont k-loops)) = refl
  _‚âà_.sameStack (_‚âà_.sameCont (_‚âà_.sameCont k-loops)) = refl
  _‚âà_.sameFlags (_‚âà_.sameCont (_‚âà_.sameCont (_‚âà_.sameCont k-loops))) = refl
  _‚âà_.sameStackSize (_‚âà_.sameCont (_‚âà_.sameCont (_‚âà_.sameCont k-loops))) = refl
  _‚âà_.sameStack (_‚âà_.sameCont (_‚âà_.sameCont (_‚âà_.sameCont k-loops))) = refl
  _‚âà_.sameCont (_‚âà_.sameCont (_‚âà_.sameCont (_‚âà_.sameCont k-loops))) = k-loops

  some-programs-do-not-halt : ¬¨ Halts·µê k
  some-programs-do-not-halt (n , prf) = helper n prf
    where
    helper : (n : ‚Ñï) ‚Üí stop (flags (run·µê k for n steps)) ‚â° 1b ‚Üí ‚ä•
    helper (suc (suc (suc (suc n)))) prf =
      helper n $ subst (Œª j ‚Üí stop (flags (run·µê j for n steps)) ‚â° 1b) (sym $ machine-ext k-loops) prf

#+end_src
