* virtual machine time

#+begin_src agda2

{-# OPTIONS --safe #-}
module coursework.Machine where

open import Data.Nat using (â„•; zero; suc; NonZero; _â‰¤_; _â‰¤áµ‡_; sâ‰¤s; _*_) renaming (pred to predâ‚™)
open import Data.Nat.Properties using (â‰¤áµ‡â‡’â‰¤; _â‰¤?_) renaming (_â‰Ÿ_ to _â‰Ÿâ‚™_)
open import Data.Bool using (T) renaming (Bool to ğ”¹; false to fâ€²; true to tâ€²)
open import Data.Bool.Properties using () renaming (_â‰Ÿ_ to _â‰Ÿáµ‡_)
open import Data.Fin.Base using (Fin; zero; suc; pred; toâ„•)
open import Data.Maybe using (Maybe; nothing; just; _>>=_)
open import Function.Base using (_$_; _âˆ˜_; _âˆ˜â€²_)
open import Relation.Nullary using (Â¬_; Dec; yes; no; contradiction)
open import Relation.Nullary.Decidable using (âŒŠ_âŒ‹)
open import Function.Inverse using (_â†”_; Inverse)
open import Data.Empty using (âŠ¥)
open import Function.Equality using (_âŸ¨$âŸ©_)
open Inverse

open import Generics

open import Prelude
open import coursework.Bits
open Serializable

#+end_src

* Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€ Ñ„Ğ»Ğ°Ğ³Ğ¾Ğ²
** Ğ•ÑĞ»Ğ¸ Ñ„Ğ»Ğ°Ğ³ ~stop~ Ğ¿Ğ¾Ğ´Ğ½ÑÑ‚, Ñ‚Ğ¾ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ¾Ñ€ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½, Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¹ Ğ¿Ñ€ĞµĞºÑ€Ğ°Ñ‰Ğ°ĞµÑ‚ÑÑ
** ~overflow~ Ğ²Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ğ¿Ñ€Ğ¸ Ñ†ĞµĞ»Ğ¾Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ½Ğ¾Ğ¼ Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ² Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸ÑÑ… ÑĞ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ¸ ÑƒĞ¼Ğ½Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
   Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ

#+begin_src agda2

record Flags : Typeâ‚€ where
  constructor mkFlags
  field
    stop     : Bit
    overflow : Bit
open Flags

instance
  decEqFlags : DecEq Flags
  DecEq._â‰Ÿ_ decEqFlags x y with stop x â‰Ÿ stop y
  ... | no Â¬f = no Î» p â†’ Â¬f (cong stop p)
  ... | yes f with overflow x â‰Ÿ overflow y
  ... | no Â¬o = no Î» p â†’ Â¬o (cong overflow p)
  ... | yes o = yes (congâ‚‚ mkFlags f o)

initFlags : Flags
initFlags = record
  { stop     = 0b
  ; overflow = 0b
  }

stopá¶  : Flags â†’ Flags
stopá¶  f = record f { stop = 1b }

#+end_src

* ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° ĞºĞ¾Ğ¼Ğ¿ÑŒÑÑ‚ĞµÑ€Ğ°
Ğ’Ğ¼ĞµÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¸Ğ²Ñ‹Ñ‡Ğ½Ğ¾Ğ¹ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ñ‹ Ñ„Ğ¾Ğ½ ĞĞµĞ¹Ğ¼Ğ°Ğ½Ğ° Ğ±ÑƒĞ´ĞµĞ¼ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ“Ğ°Ñ€Ğ²Ğ°Ñ€Ğ´ÑĞºÑƒÑ.
Ğ”Ğ»Ñ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¹ ĞµÑÑ‚ÑŒ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾Ğµ read-only Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ ~program~, instruction pointer ~ip~
ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ ĞºÑƒĞ´Ğ°-Ñ‚Ğ¾ Ğ²Ğ½ÑƒÑ‚Ñ€ÑŒ ÑÑ‚Ğ¾Ğ³Ğ¾ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğ°, Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ½Ğ° Ğ½ÑƒĞ»ĞµĞ²Ğ¾Ğ¹ Ğ±Ğ°Ğ¹Ñ‚.
Ğ”Ğ»Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ĞµÑÑ‚ÑŒ ÑÑ‚ĞµĞº.

ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ ĞµĞ´Ğ¸Ğ½Ğ¸Ñ†Ğ° Ğ°Ğ´Ñ€ĞµÑĞ°Ñ†Ğ¸Ğ¸ â€” 1 Ğ±Ğ°Ğ¹Ñ‚.
Ğ Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ¾Ñ€Ğ½Ğ¾Ğ³Ğ¾ ÑĞ»Ğ¾Ğ²Ğ° â€” 2 Ğ±Ğ°Ğ¹Ñ‚Ğ°.

#+begin_src agda2

record MS (programSize : â„•) (program : ByteArray programSize) : Typeâ‚€ where
  constructor mkMS
  field
    ip        : BytePtr programSize
    flags     : Flags
    stackSize : â„•
    stack     : ByteArray stackSize
open MS

initMachine : (ps : â„•) â¦ƒ _ : NonZero ps â¦„
              (p : ByteArray ps) (ss : â„•) â†’
              MS ps p
initMachine (suc ps) p ss = record
  { ip = zero
  ; flags = initFlags
  ; stackSize = ss
  ; stack = memset 0byte
  }

private
  variable
    ps psâ€² ss : â„•
    p : ByteArray ps

-- it wraps around
nextIpâ€² : BytePtr (suc ps) â†’ BytePtr (suc ps)
nextIpâ€² {ps} ip with toâ„• ip â‰Ÿâ‚™ ps
... | yes _ = zero
... | no  p with helper ip p
  where
  helper : {ps : â„•} â†’ (ip : BytePtr (suc ps)) â†’ (toâ„• ip â‰¢ ps) â†’ Î£ â„• Î» psâ€² â†’ ps â‰¡ suc psâ€²
  helper {zero        } zero       p = contradiction refl p
  helper {suc zero    } zero       _ = zero , refl
  helper {suc zero    } (suc zero) p = contradiction refl p
  helper {suc (suc ps)} _          _ = suc ps , refl
... | psâ€² , refl with ip
... | zero    = suc zero
... | suc ipâ€² = suc (nextIpâ€² ipâ€²)

iterate : â„• â†’ (A â†’ A) â†’ (A â†’ A)
iterate 0       _ x = x
iterate (suc n) f x = iterate n f (f x)

nextIp : BytePtr (suc ps) â†’ BytePtr (suc ps)
nextIp = iterate 2 nextIpâ€²

#+end_src

* Instruction set

#+begin_src agda2

data Instr : Typeâ‚€ where
  push         :     Byte â†’ Instr
  pop          :            Instr
  add          :            Instr
-- sub mul  :            Instr
  eq           :            Instr
--  neq le gt :            Instr
--   skip         :     Byte â†’ Instr
  skipIf       : ğ”¹ â†’ Byte â†’ Instr
  nop halt     :            Instr

InstrD : HasDesc Instr
InstrD = deriveDesc Instr

instance
  showInstr : Show Instr
  showInstr = deriveShow InstrD

bitsAndBytes : Bits 16 â†” ByteArray 2
to bitsAndBytes = record
  { _âŸ¨$âŸ©_ = Î» where
      (bâ‚€ âˆ· bâ‚ âˆ· bâ‚‚ âˆ· bâ‚ƒ âˆ· bâ‚„ âˆ· bâ‚… âˆ· bâ‚† âˆ· bâ‚‡ âˆ· bs) â†’ (bâ‚€ âˆ· bâ‚ âˆ· bâ‚‚ âˆ· bâ‚ƒ âˆ· bâ‚„ âˆ· bâ‚… âˆ· bâ‚† âˆ· bâ‚‡ âˆ· []) âˆ· bs âˆ· []
  ; cong = Î» { refl â†’ refl }
  }
from bitsAndBytes = record
  { _âŸ¨$âŸ©_ = Î» where
      (x âˆ· y âˆ· []) â†’ x ++ y
  ; cong = Î» { refl â†’ refl }
  }
inverse-of bitsAndBytes = record
  { left-inverse-of = Î» where
      (bâ‚€ âˆ· bâ‚ âˆ· bâ‚‚ âˆ· bâ‚ƒ âˆ· bâ‚„ âˆ· bâ‚… âˆ· bâ‚† âˆ· bâ‚‡ âˆ· bs) â†’ refl
  ; right-inverse-of = Î» where
      ((bâ‚€ âˆ· bâ‚ âˆ· bâ‚‚ âˆ· bâ‚ƒ âˆ· bâ‚„ âˆ· bâ‚… âˆ· bâ‚† âˆ· bâ‚‡ âˆ· []) âˆ· bs âˆ· []) â†’ refl
  }
  
serInstr : Serializable Instr 2
serInstr = record { encode = encodeâ€² ; decode = decodeâ€² ; decodeâˆ˜encode = inversesâ‚ ; encodeâˆ˜decode = inversesâ‚‚ }
  where
  encodeâ€² : Instr â†’ ByteArray 2
  encodeâ€² halt          = 0byte                                        âˆ· 0byte âˆ· []
  encodeâ€² nop           = (0b âˆ· 0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² (skip b)      = (0b âˆ· 0b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· b     âˆ· []
  encodeâ€² (skipIf fâ€² b) = (0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· b     âˆ· []
  encodeâ€² (skipIf tâ€² b) = (0b âˆ· 1b âˆ· 0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· b     âˆ· []
  encodeâ€² (push b)      = (0b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· b     âˆ· []
  encodeâ€² pop           = (0b âˆ· 1b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
  encodeâ€² add           = (1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² sub           = (1b âˆ· 0b âˆ· 0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
  encodeâ€² eq            = (1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² mul           = (1b âˆ· 0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² neq           = (1b âˆ· 1b âˆ· 0b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² le            = (1b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []
--   encodeâ€² gt            = (1b âˆ· 1b âˆ· 1b âˆ· 1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· 0byte âˆ· []

  decodeâ€² : ByteArray 2 â†’ Maybe Instr
  decodeâ€² (0byteâ‚š                                               âˆ· 0byteâ‚š âˆ· []) = just halt
  decodeâ€² ((0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just nop
--   decodeâ€² ((0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· b      âˆ· []) = just (skip b)
  decodeâ€² ((0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· b      âˆ· []) = just (skipIf fâ€² b)
  decodeâ€² ((0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· b      âˆ· []) = just (skipIf tâ€² b)
  decodeâ€² ((0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· b      âˆ· []) = just (push b)
  decodeâ€² ((0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just pop
  decodeâ€² ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just add
--   decodeâ€² ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just sub
--   decodeâ€² ((1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just mul
  decodeâ€² ((1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just eq
--   decodeâ€² ((1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just neq
--   decodeâ€² ((1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just le
--   decodeâ€² ((1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) = just gt
  decodeâ€² _ = nothing
  
  inversesâ‚ : (i : Instr) â†’ decodeâ€² (encodeâ€² i) â‰¡ just i
  inversesâ‚ (push x) = refl
  inversesâ‚ pop = refl
  inversesâ‚ add = refl
--   inversesâ‚ sub = refl
--   inversesâ‚ mul = refl
  inversesâ‚ eq = refl
--   inversesâ‚ neq = refl
--   inversesâ‚ le = refl
--   inversesâ‚ gt = refl
--   inversesâ‚ (skip _) = refl
  inversesâ‚ (skipIf fâ€² _) = refl
  inversesâ‚ (skipIf tâ€² _) = refl
  inversesâ‚ nop = refl
  inversesâ‚ halt = refl

  inversesâ‚‚ : (ba : ByteArray 2) {i : Instr} â†’ decodeâ€² ba â‰¡ just i â†’ ba â‰¡ encodeâ€² i
  inversesâ‚‚ (0byteâ‚š                                               âˆ· 0byteâ‚š âˆ· []) refl = refl
  inversesâ‚‚ ((0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
--   inversesâ‚‚ ((0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· _      âˆ· []) refl = refl
  inversesâ‚‚ ((0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· _      âˆ· []) refl = refl
  inversesâ‚‚ ((0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· _      âˆ· []) refl = refl
  inversesâ‚‚ ((0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· _      âˆ· []) refl = refl
  inversesâ‚‚ ((0bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
  inversesâ‚‚ ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
--   inversesâ‚‚ ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
--   inversesâ‚‚ ((1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
  inversesâ‚‚ ((1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
--   inversesâ‚‚ ((1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
--   inversesâ‚‚ ((1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl
--   inversesâ‚‚ ((1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· 0byteâ‚š âˆ· []) refl = refl

instance
  serBool : Serializable ğ”¹ 1
  serBool = record
    { encode = Î» where
        fâ€² â†’ 0byte âˆ· []
        tâ€² â†’ (1b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· 0b âˆ· []) âˆ· []
    ; decode = Î» where
        (0byteâ‚š âˆ· []                                              ) â†’ just fâ€²
        ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· []) â†’ just tâ€²
        _                                                           â†’ nothing
    ; decodeâˆ˜encode = Î» where
        fâ€² â†’ refl
        tâ€² â†’ refl
    ; encodeâˆ˜decode = Î» where
        (0byteâ‚š âˆ· []) refl â†’ refl
        ((1bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· 0bâ‚š âˆ· []) âˆ· []) refl â†’ refl
    }

decodeAsâ„• : Byte â†’ â„•
decodeAsâ„• = fromDigits âˆ˜â€² toList

#+end_src

* Ğ˜Ğ½Ñ‚ĞµÑ€Ğ¿Ñ€ĞµÑ‚Ğ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´
** fetch command at ip
** if it's invalid stop
** if it's valid then execute it and advance ip

#+begin_src agda2

private
  instance
    â‰¤-dec : {p : T (m â‰¤áµ‡ n)} â†’ m â‰¤ n
    â‰¤-dec {p = p} = â‰¤áµ‡â‡’â‰¤ _ _ p

fetch : MS ps p â†’ Maybe (ByteArray 2)
fetch {ps = suc (suc ps)} {p = p} ms with toâ„• (ip ms) â‰¤? ps
... | yes q = just $ slice_at_as_ p (ip ms) 2 â¦ƒ sâ‰¤s (sâ‰¤s q) â¦„
... | no  _ = nothing
fetch {ps = _           } _ = nothing

stopáµ : MS ps p â†’ MS ps p
stopáµ ms = record ms { flags = stopá¶  $ ms .flags }

execute : MS (suc ps) p â†’ Instr â†’ MS (suc ps) p
execute ms (push b) = record ms { ip = nextIp (ip ms) ; stackSize = suc (stackSize ms) ; stack = b âˆ· stack ms }
execute ms pop with stackSize ms in sEq
... | suc ss = record ms { ip = nextIp (ip ms) ; stackSize = ss ; stack = tail (subst ByteArray sEq (stack ms)) }
... | 0      = stopáµ ms
execute ms add with stackSize ms in sEq
... | 0            = stopáµ ms
... | 1            = stopáµ ms
... | suc (suc ss) with slice (subst ByteArray sEq (stack ms)) at zero as 2
... | bâ‚ âˆ· bâ‚‚ âˆ· [] = let carry , res = bâ‚ + bâ‚‚
                     in record ms { ip = nextIp (ip ms) ; flags = record { stop = stop (flags ms) ; overflow = carry } ; stackSize = suc ss ; stack = res âˆ· drop 2 (subst ByteArray sEq (stack ms)) }
execute ms eq with stackSize ms in sEq
... | 0 = stopáµ ms
... | 1 = stopáµ ms
... | suc (suc ss) with slice (subst ByteArray sEq (stack ms)) at zero as 2
... | bâ‚ âˆ· bâ‚‚ âˆ· [] with âŒŠ bâ‚ â‰Ÿ bâ‚‚ âŒ‹
... | d = record ms { ip = nextIp (ip ms) ; stackSize = suc ss ; stack = single (encode serBool d) âˆ· drop 2 (subst ByteArray sEq (stack ms)) }
execute ms (skipIf c n) with stackSize ms in sEq
... | 0      = stopáµ ms
... | suc ss with decode serBool (take 1 (subst ByteArray sEq (stack ms)))
... | nothing = stopáµ ms
... | just câ€² with âŒŠ c â‰Ÿáµ‡ câ€² âŒ‹
... | tâ€² = record ms { ip = iterate (decodeAsâ„• n) nextIpâ€² (ip ms) ; stackSize = ss; stack = tail (subst ByteArray sEq (stack ms))}
... | fâ€² = record ms { ip = nextIp (ip ms) ; stackSize = ss; stack = tail (subst ByteArray sEq (stack ms))}
execute ms nop = record ms { ip = nextIp (ip ms) }
execute ms halt = stopáµ ms

-- fetch instruction, decode, execute
step : MS (suc ps) p â†’ MS (suc ps) p
step ms with stop (flags ms)
... | 1bâ‚š = ms
... | 0bâ‚š with fetch ms >>= decode serInstr
... | nothing = stopáµ ms
... | just i  = execute ms i

record _â‰ˆ_ (x y : MS (suc ps) p) : Typeâ‚€ where
  coinductive
  field
    sameFlags     : flags x â‰¡ flags y
    sameStackSize : stackSize x â‰¡ stackSize y
    sameStack     : subst ByteArray sameStackSize (stack x) â‰¡ stack y
    sameCont      : step x â‰ˆ step y

MachineExtensionality : Typeâ‚€
MachineExtensionality = âˆ€ {ps p} â†’ {x y : MS (suc ps) p} â†’ x â‰ˆ y â†’ x â‰¡ y

assemble : Vec Instr n â†’ ByteArray (n * 2)
assemble []       = []
assemble (i âˆ· is) = encode serInstr i ++ assemble is

run_for_steps : MS (suc ps) p â†’ â„• â†’ MS (suc ps) p
run ms for 0     steps = ms
run ms for suc n steps = run (step ms) for n steps

Halts : MS (suc ps) p â†’ Typeâ‚€
Halts ms = Î£ â„• Î» n â†’ stop (flags (run ms for n steps)) â‰¡ 1b

module Test {machine-ext : MachineExtensionality} where

  trivial : MS _ _
  trivial = initMachine _ (assemble $ push 1byte âˆ· push 1byte âˆ· add âˆ· halt âˆ· []) 0

  trivial-halts : Halts trivial
  trivial-halts = 4 , refl

  loopyBoy : Vec Instr _
  loopyBoy = push 0byte âˆ· push 0byte âˆ· add âˆ· skipIf fâ€² (0b âˆ· 1b âˆ· replicate 0b) âˆ· []

  k : MS 8 _
  k = initMachine _ (assemble loopyBoy) 0

  k-loops : k â‰ˆ (run k for 4 steps)
  _â‰ˆ_.sameFlags k-loops = refl
  _â‰ˆ_.sameStackSize k-loops = refl
  _â‰ˆ_.sameStack k-loops = refl
  _â‰ˆ_.sameFlags (_â‰ˆ_.sameCont k-loops) = refl
  _â‰ˆ_.sameStackSize (_â‰ˆ_.sameCont k-loops) = refl
  _â‰ˆ_.sameStack (_â‰ˆ_.sameCont k-loops) = refl
  _â‰ˆ_.sameFlags (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops)) = refl
  _â‰ˆ_.sameStackSize (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops)) = refl
  _â‰ˆ_.sameStack (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops)) = refl
  _â‰ˆ_.sameFlags (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops))) = refl
  _â‰ˆ_.sameStackSize (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops))) = refl
  _â‰ˆ_.sameStack (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops))) = refl
  _â‰ˆ_.sameCont (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont (_â‰ˆ_.sameCont k-loops))) = k-loops

  some-programs-do-not-halt : Â¬ Halts k
  some-programs-do-not-halt (n , prf) = helper n prf
    where
    helper : (n : â„•) â†’ stop (flags (run k for n steps)) â‰¡ 1b â†’ âŠ¥
    helper (suc (suc (suc (suc n)))) prf =
      helper n $ subst (Î» j â†’ stop (flags (run j for n steps)) â‰¡ 1b) (sym $ machine-ext k-loops) prf

#+end_src
