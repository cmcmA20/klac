* —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ø—Ä–æ–∫–∞—à–ª–∏–≤–∞–Ω–∏—è
#+begin_src agda2

{-# OPTIONS --safe #-}
module Day4 where

open import Prelude

open import Data.List using (List; []; _‚à∑_; _++_; map)
open import Data.Nat using (‚Ñï; zero; suc; _+_)
open import Function.Base using (_$_)
open import Relation.Nullary using (¬¨_)

#+end_src

* –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω–¥—É–∫—Ü–∏—è, —ç–ª–∏–º–∏–Ω–∞—Ç–æ—Ä—ã
–û—Ç–ª–∏—á–∏–µ /–∏–Ω–¥—É–∫—Ü–∏–∏/ –æ—Ç /—Ä–µ–∫—É—Ä—Å–∏–∏/.
—Ä–∞–∑–æ–±—Ä–∞—Ç—å –∏–Ω–¥—É–∫—Ü–∏—é –¥–ª—è –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö, –Ω–∞ –¥–æ–º –∏–Ω–¥—É–∫—Ü–∏—è –¥–ª—è ùîπ –∏ List A

#+begin_src agda2

-- nat-ind‚Ä≤ : {P : ‚Ñï ‚Üí Type‚ÇÄ} ‚Üí P 0 ‚Üí ((n : ‚Ñï) ‚Üí P n ‚Üí P (suc n)) ‚Üí (m : ‚Ñï) ‚Üí P m
nat-ind : {P : ‚Ñï ‚Üí ùì§‚ÇÄ} ‚Üí P 0 ‚Üí (Œ†[ n ‚àà ‚Ñï ] (P n ‚Üí P (suc n))) ‚Üí Œ†[ m ‚àà ‚Ñï ] P m
nat-ind p‚ÇÄ p‚Çô zero    = p‚ÇÄ
nat-ind p‚ÇÄ p‚Çô (suc m) = p‚Çô m (nat-ind p‚ÇÄ p‚Çô m)

nat-rec : {R : Type‚ÇÄ} ‚Üí R ‚Üí (R ‚Üí R) ‚Üí (m : ‚Ñï) ‚Üí R
nat-rec {R} z s = nat-ind {P = Œª _ ‚Üí R} z (Œª _ ‚Üí s)

cons-nat-rec-is-id : (m : ‚Ñï) ‚Üí nat-rec {‚Ñï} 0 suc m ‚â° m
cons-nat-rec-is-id zero = refl
cons-nat-rec-is-id (suc m) = cong suc (cons-nat-rec-is-id m)

-- foldr
list-rec : {A R : Type ‚Ñì} ‚Üí R ‚Üí (A ‚Üí R ‚Üí R) ‚Üí (x : List A) ‚Üí R
list-rec z _   []       = z
list-rec z _‚äï_ (x ‚à∑ xs) = x ‚äï (list-rec z _‚äï_ xs)

map-as-list-rec : {A B : Type ‚Ñì} (f : A ‚Üí B) ‚Üí List A ‚Üí List B
map-as-list-rec f xs = list-rec [] (Œª x acc ‚Üí f x ‚à∑ acc) xs

same-map : {A B : Type ‚Ñì} (f : A ‚Üí B) (xs : List A) ‚Üí map-as-list-rec f xs ‚â° Data.List.map f xs
same-map f [] = refl
same-map f (x ‚à∑ xs) = cong (f x ‚à∑_) (same-map f xs)

-- cons-list-rec-is-id : {A : Type ‚Ñì} (xs : List A) ‚Üí list-rec [] (_‚à∑_) xs ‚â° xs
-- cons-list-rec-is-id = {!!}

#+end_src

* –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤, —Å—Ç–∏–ª–∏

#+begin_src agda2

suc-inj : (x y : ‚Ñï) ‚Üí suc x ‚â° suc y ‚Üí x ‚â° y
suc-inj a _ refl = refl

suc-plus-comm : (a b : ‚Ñï) ‚Üí a + suc b ‚â° suc (a + b)
suc-plus-comm zero _ = refl
suc-plus-comm (suc a) b = cong suc (suc-plus-comm _ _)

plus-comm : (a b : ‚Ñï) ‚Üí a + b ‚â° b + a
plus-comm zero zero = refl
plus-comm zero (suc b) = cong suc (plus-comm _ b)
plus-comm (suc a) zero = cong suc (plus-comm a _)
plus-comm (suc a) (suc b) = cong suc $
  begin
    a + suc b
  ‚â°‚ü® suc-plus-comm _ _ ‚ü©
    suc (a + b)
  ‚â°‚ü® cong suc (plus-comm a _) ‚ü©
    suc (b + a)
  ‚â°Àò‚ü® suc-plus-comm _ _ ‚ü©
    b + suc a
  ‚àé where open ‚â°-Reasoning

#+end_src

** –î–æ–∫–∞–∑—ã–≤–∞–µ–º —Å –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–º–∏ —à–∞–≥–∞–º–∏ –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö

#+begin_src agda2

invert-beginner : (a b : ‚Ñï) (r : a + a ‚â° b + b) ‚Üí a ‚â° b
invert-beginner zero zero _ = refl
invert-beginner (suc a) (suc b) r =
  let
    r‚ÇÇ = suc-inj _ _ r
    r‚ÇÉ = trans (plus-comm _ a) r‚ÇÇ
    r‚ÇÑ = trans r‚ÇÉ (plus-comm b _)
    r‚ÇÖ = suc-inj _ _ r‚ÇÑ
  in cong suc (invert-beginner a b r‚ÇÖ)

#+end_src

** –î–æ–∫–∞–∑—ã–≤–∞–µ–º –≤ —Å—Ç–∏–ª–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤

#+begin_src agda2

invert-cylon : (a b : ‚Ñï) ‚Üí a + a ‚â° b + b ‚Üí a ‚â° b
invert-cylon zero zero _ = refl
invert-cylon (suc a) (suc b) r =
  cong suc $ invert-beginner _ _ $ suc-inj _ _ $ plus-comm _ a ‚àô suc-inj _ _ r ‚àô plus-comm b _
  where
  _‚àô_ = trans
  infixr 8 _‚àô_

#+end_src

** –î–æ–∫–∞–∑—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ equality reasoning

#+begin_src agda2

invert-reasoning : (a b : ‚Ñï) ‚Üí a + a ‚â° b + b ‚Üí a ‚â° b
invert-reasoning zero zero _ = refl
invert-reasoning (suc a) (suc b) r = cong suc $ invert-reasoning _ _ $ suc-inj _ _ $
  begin
    suc (a + a)
  ‚â°‚ü® plus-comm _ a ‚ü©
    a + suc a
  ‚â°‚ü® suc-inj _ _ r ‚ü©
    b + suc b
  ‚â°‚ü® plus-comm b _ ‚ü©
    suc (b + b)
  ‚àé where open ‚â°-Reasoning

#+end_src

* –†–µ–≥—É–ª—è—Ä–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è

#+begin_src agda2

data RegExp (A : Type ‚Ñì) : Type ‚Ñì where
  √∏    :                       RegExp A
  Œµ    :                       RegExp A
  #_   : A        ‚Üí            RegExp A
  _<>_ : RegExp A ‚Üí RegExp A ‚Üí RegExp A
  _‚à£_  : RegExp A ‚Üí RegExp A ‚Üí RegExp A
  _*   : RegExp A ‚Üí            RegExp A
infixr 5 _<>_

private
  variable
    A : Type ‚Ñì
    x : A
    s s‚ÇÅ s‚ÇÇ : List A
    re re‚ÇÅ re‚ÇÇ : RegExp A

infix 0 _=~_
data _=~_ {A : Type ‚Ñì} : List A ‚Üí RegExp A ‚Üí Type ‚Ñì where
  MEmpty  : []     =~ Œµ
  MChar   : x ‚à∑ [] =~ # x
  MApp    : s‚ÇÅ =~ re‚ÇÅ ‚Üí
            s‚ÇÇ =~ re‚ÇÇ ‚Üí
            s‚ÇÅ ++ s‚ÇÇ =~ re‚ÇÅ <> re‚ÇÇ
  MUnionL : s‚ÇÅ =~ re‚ÇÅ ‚Üí
            s‚ÇÅ =~ re‚ÇÅ ‚à£ re‚ÇÇ
  MUnionR : s‚ÇÇ =~ re‚ÇÇ ‚Üí
            s‚ÇÇ =~ re‚ÇÅ ‚à£ re‚ÇÇ
  MStar0  : [] =~ re *
  MStarS  : s‚ÇÅ =~ re ‚Üí
            s‚ÇÇ =~ re * ‚Üí
            s‚ÇÅ ++ s‚ÇÇ =~ re *

ex‚ÇÅ : 1 ‚à∑ [] =~ # 1
ex‚ÇÅ = MChar

ex‚ÇÇ : 1 ‚à∑ 2 ‚à∑ [] =~ # 1 <> # 2
ex‚ÇÇ = MApp MChar MChar

ex‚ÇÉ : ¬¨ (1 ‚à∑ 2 ‚à∑ [] =~ # 1)
ex‚ÇÉ ()

reList : List A ‚Üí RegExp A
reList []       = Œµ
reList (x ‚à∑ xs) = # x <> reList xs

ex‚ÇÑ : 1 ‚à∑ 2 ‚à∑ 3 ‚à∑ [] =~ reList (1 ‚à∑ 2 ‚à∑ 3 ‚à∑ [])
ex‚ÇÑ = MApp MChar (MApp MChar (MApp MChar MEmpty))

matchStar : (s =~ re) ‚Üí (s =~ re *)
matchStar {re = re} x = subst (_=~ re *) nil-right-neutral (MStarS x MStar0)
  where
  nil-right-neutral : s ++ [] ‚â° s
  nil-right-neutral {s = []} = refl
  nil-right-neutral {s = x ‚à∑ s} = cong (x ‚à∑_) nil-right-neutral

#+end_src
